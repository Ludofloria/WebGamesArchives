package db;

import Common;
import mt.db.Types;

class ExploItem extends neko.db.Object {

	static var TABLE_IDS = ["zoneId","toolId","cellId","isBroken"];
	static var INDEXES = [ ["zoneId","cellId","toolId"],["toolId","isBroken"] ];

	static var RELATIONS = function() {
		return [
            { key : "zoneId",    prop : "explo",    manager : Explo.manager, lock : false },
        ];
	}

	public static var manager = new ExploItemManager();

	public var zoneId(default, null)	: SInt;
	public var cellId 	: SInt;
	public var toolId	: SInt;
	public var isBroken	: SBool;
	public var count	: SInt;
	public var explo(dynamic, dynamic)	: Explo;
	public var life : SInt;

	public static function create(explo:Explo, tid:Int, ?count=1, ?fl_br=false) {
		var o = manager._getByToolId( explo, tid, fl_br );
		if( o != null ) {
			o.count+=count;
			o.update();
			return o;
		}
		var o = new ExploItem();
		o.cellId = explo.getCurrentCellId();
		o.count = count;
		o.explo = explo;
		o.toolId = tid;
		o.isBroken = fl_br;
		o.insert();
		return o;
	}

	public function new() {
		super();
		isBroken = false;
		count = 1;
		life = 0;
	}

	public static function categorizeItemList(list:List<ExploItem>) {
		var hash = new Hash();
		for (zitem in list) {
			var tool = XmlData.getTool(zitem.toolId);
			var key = Tool.getCategoryName(tool);
			if ( hash.get(key)==null )
				hash.set(key,new List());
			hash.get(key).add(zitem);
		}
		var clist = new Array();
		for (key in hash.keys()) {
			clist.push({
				key		: key,
				list	: hash.get(key),
			});
		}
		clist.sort(function(a,b) {
			if (a.key==Text.get.BankCat_Rsc) return -1;
			if (b.key==Text.get.BankCat_Rsc) return 1;
			if (a.key==Text.get.BankCat_None) return 1;
			if (b.key==Text.get.BankCat_None) return -1;
			if (a.key<b.key) return -1;
			if (a.key>b.key) return 1;
			return 0;
		});
		return clist;
	}

	override public function delete() {
		if( count<=1 )
			super.delete();
		else {
			count--;
			update();
		}
	}
}


class ExploItemManager extends neko.db.Manager<ExploItem> {
	
	public function new(){
		super(ExploItem);
	}

	private function addOptionalReq( fl_br:Bool ) {
		var req = "";
		if ( fl_br!=null )
			req += " AND isBroken="+fl_br;
		return req;
	}

	public function exists( zone: Zone, tid : Int, ?fl_br:Bool ) {
		var req = "SELECT count(*) FROM ExploItem WHERE zoneId="+zone.id+" AND toolId =" + tid + addOptionalReq(fl_br);
		return execute(req).getIntResult(0) > 0;
	}
	
	public function _getByToolId( explo: Explo, tid : Int, fl_br:Bool ) {
		var query = select( "zoneId="+explo.zoneId+" AND cellId="+explo.getCurrentCellId()+" AND toolId="+tid + addOptionalReq(fl_br) );
		return object(query, true);
	}
	
	public function _getExploCellItems( explo: Explo, ?lock=false, ?fl_vis:Bool ) {
		if( lock ) {
			var data = new List();
			var rs = objects(select("zoneId=" + explo.zoneId + " AND cellId="+explo.getCurrentCellId()+" ORDER BY toolId ASC" ), true);
			for( r in rs ) {
				data.push( getWithKeys( { zoneId:explo.zoneId, toolId:r.toolId, isBroken:r.isBroken } ) );
			}
			return data;
		} else {
			var r = selectReadOnly("zoneId=" + explo.zoneId + " AND cellId="+explo.getCurrentCellId()+" ORDER BY toolId ASC" );
			return Lambda.list( objects(r, false) );
		}
	}
	
	public function getAllToolsInMap(map:Map, toolId:Int):List<db.ExploItem> {
		var mapZoneIds = db.Zone.manager._getZoneIds(map);
		return objects(select("toolId=" + toolId + " AND zoneId IN(" + mapZoneIds.join(",") + ")"), false);
	}
	
}
